/**
 * Copyright (C) 2017 - Marc Henrard.
 */
package marc.henrard.analysis.pricer.capfloor;

import static com.opengamma.strata.basics.currency.Currency.EUR;
import static com.opengamma.strata.basics.date.HolidayCalendarIds.EUTA;
import static com.opengamma.strata.basics.index.IborIndices.EUR_EURIBOR_6M;

import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.Period;
import java.time.ZoneId;

import org.testng.annotations.Test;

import com.opengamma.strata.basics.ReferenceData;
import com.opengamma.strata.basics.date.BusinessDayAdjustment;
import com.opengamma.strata.basics.date.BusinessDayConventions;
import com.opengamma.strata.basics.schedule.Frequency;
import com.opengamma.strata.basics.schedule.PeriodicSchedule;
import com.opengamma.strata.basics.schedule.RollConventions;
import com.opengamma.strata.basics.schedule.StubConvention;
import com.opengamma.strata.basics.value.ValueSchedule;
import com.opengamma.strata.pricer.rate.ImmutableRatesProvider;
import com.opengamma.strata.product.capfloor.IborCapFloorLeg;
import com.opengamma.strata.product.capfloor.ResolvedIborCapFloorLeg;
import com.opengamma.strata.product.common.PayReceive;
import com.opengamma.strata.product.swap.IborRateCalculation;

import marc.henrard.analysis.dataset.MulticurveStandardEurDataSet;
import marc.henrard.analysis.dataset.RationalParametersDataSet;
import marc.henrard.murisq.basics.data.export.ExportUtils;
import marc.henrard.risq.model.rationalmulticurve.RationalTwoFactorHWShapePlusCstParameters;
import marc.henrard.risq.pricer.capfloor.SingleCurrencyModelCapFloorLegPricer;
import marc.henrard.risq.pricer.capfloor.RationalTwoFactorCapletFloorletPeriodSemiExplicitPricer;

/**
 * Produce files with implied Bachelier volatilities generated by cap/floor priced with a rational multi-curve model.
 * <p>
 * The implied volatilities are printed on the console in csv-like format and are easy to graph in Matlab.
 * 
 * @author Marc Henrard
 */
@Test
public class RationalTwoFactorCapFloorImpliedVolatilityAnalysis {

  private static final ReferenceData REF_DATA = ReferenceData.standard();
  private static final LocalDate VALUATION_DATE = LocalDate.of(2017, 9, 6);
  private static final LocalTime VALUATION_TIME = LocalTime.of(11, 0);
  private static final ZoneId VALUATION_ZONE = ZoneId.of("Europe/Brussels");
  private static final BusinessDayAdjustment BUSINESS_ADJ = BusinessDayAdjustment.of(
      BusinessDayConventions.MODIFIED_FOLLOWING, EUTA);

  private static final RationalTwoFactorCapletFloorletPeriodSemiExplicitPricer PRICER_CAPLET_S_EX =
      RationalTwoFactorCapletFloorletPeriodSemiExplicitPricer.DEFAULT;
  private static final SingleCurrencyModelCapFloorLegPricer PRICER_LEG_S_EX =
      new SingleCurrencyModelCapFloorLegPricer(PRICER_CAPLET_S_EX);

  public static final ImmutableRatesProvider MULTICURVE =
      MulticurveStandardEurDataSet.multicurve(VALUATION_DATE, REF_DATA);

  public static final RationalTwoFactorHWShapePlusCstParameters RATIONAL2 =
      RationalParametersDataSet.twoFactorHWShaped(VALUATION_TIME, VALUATION_ZONE, MULTICURVE.discountFactors(EUR));

  /* Descriptions of cap/floor */
  private static final Period[] MATURITIES_PER = new Period[] {
      Period.ofYears(1), Period.ofYears(2), Period.ofYears(3), Period.ofYears(4), Period.ofYears(5),
      Period.ofYears(6), Period.ofYears(7), Period.ofYears(8), Period.ofYears(9), Period.ofYears(10)};
  private static final int NB_MATURITIES = MATURITIES_PER.length;
//  private static final double[] STRIKES = new double[] 
//      {-0.0025, 0.0000, 0.0050, 0.0100, 0.0150, 0.0200};  // TODO: Choose between the two sets of strikes
  private static final double[] STRIKES = 
    {-0.0025, 0.0000, 0.0025, 0.0050, 0.0075, 0.0100, 0.0150, 0.0200, 0.0250, 0.0300};
  private static final int NB_STRIKES = STRIKES.length;
  private static final double NOTIONAL = 100_000_000.0d;

  /* Computes the term structure of implied volatilities with the initial set of parameters. */
  public void term_structure_init() throws IOException {
    String[] headers = new String[NB_STRIKES + 1];
    headers[0] = "0.0";
    for (int k = 0; k < NB_STRIKES; k++) {
      headers[k + 1] = Double.toString(STRIKES[k]);
    }
    LocalDate spot = EUR_EURIBOR_6M.calculateEffectiveFromFixing(VALUATION_DATE, REF_DATA);
    double[][] pv = new double[NB_MATURITIES][NB_STRIKES + 1];
    double[][] iv = new double[NB_MATURITIES][NB_STRIKES + 1];
    for (int i = 0; i < NB_MATURITIES; i++) {
      iv[i][0] = MATURITIES_PER[i].getYears();
      LocalDate maturity = spot.plus(MATURITIES_PER[i]);
      PeriodicSchedule paySchedule =
          PeriodicSchedule.of(spot, maturity, Frequency.P6M, BUSINESS_ADJ, StubConvention.NONE,
              RollConventions.NONE);
      for (int k = 0; k < NB_STRIKES; k++) {
        IborCapFloorLeg leg = IborCapFloorLeg.builder()
            .currency(EUR)
            .calculation(IborRateCalculation.of(EUR_EURIBOR_6M))
            .capSchedule(ValueSchedule.of(STRIKES[k]))
            .notional(ValueSchedule.of(NOTIONAL))
            .paymentSchedule(paySchedule)
            .payReceive(PayReceive.PAY).build();
        ResolvedIborCapFloorLeg resolvedLeg = leg.resolve(REF_DATA);
        pv[i][k + 1] = PRICER_LEG_S_EX.presentValue(resolvedLeg, MULTICURVE, RATIONAL2).getAmount();
        iv[i][k + 1] = PRICER_LEG_S_EX.impliedVolatilityBachelier(resolvedLeg, MULTICURVE, RATIONAL2);
      }
    }
    StringBuilder builder = new StringBuilder();
    ExportUtils.exportArray(headers, iv, builder);
    System.out.println(builder.toString());  // Results printed on the console
  }

  /* Computes the term structure of implied volatilities with one parameter changed. */
  public void term_structure_changes() throws IOException {
    int strikeIndex = 3;
    int parameterIndex = 3; // TODO: Parameter changed in this simulation; select of of the parameter set
//  double[] parametersChanged = {0.75, 0.50, 0.65, 0.85, 1.00}; // A1 - 0
    double[] parametersChanged = {0.50, 0.30, 0.40, 0.60, 0.70}; // b00 - 3
//  double[] parametersChanged = {0.01, 0.005, 0.0075, 0.0125, 0.015}; // eta - 4
//  double[] parametersChanged = {0.03, 0.001, 0.005, 0.05, 0.10, 0.15}; // kappa - 5
    
    int nbParamShifts = parametersChanged.length;
    String[] headers = new String[nbParamShifts + 1];
    headers[0] = "0.0";
    for (int k = 0; k < nbParamShifts; k++) {
      headers[k + 1] = Double.toString(parametersChanged[k]);
    }
    LocalDate spot = EUR_EURIBOR_6M.calculateEffectiveFromFixing(VALUATION_DATE, REF_DATA);
    double[][] iv = new double[NB_MATURITIES][nbParamShifts + 1];
    for (int i = 0; i < NB_MATURITIES; i++) {
      iv[i][0] = MATURITIES_PER[i].getYears();
      LocalDate maturity = spot.plus(MATURITIES_PER[i]);
      PeriodicSchedule paySchedule =
          PeriodicSchedule.of(spot, maturity, Frequency.P6M, BUSINESS_ADJ, StubConvention.NONE,
              RollConventions.NONE);
      IborCapFloorLeg leg = IborCapFloorLeg.builder()
          .currency(EUR)
          .calculation(IborRateCalculation.of(EUR_EURIBOR_6M))
          .capSchedule(ValueSchedule.of(STRIKES[strikeIndex]))
          .notional(ValueSchedule.of(NOTIONAL))
          .paymentSchedule(paySchedule)
          .payReceive(PayReceive.PAY).build();
      ResolvedIborCapFloorLeg resolvedLeg = leg.resolve(REF_DATA);
      for (int j = 0; j < nbParamShifts; j++) {
        RationalTwoFactorHWShapePlusCstParameters rationalShift =
            RATIONAL2.withParameter(parameterIndex, parametersChanged[j]);
        iv[i][j + 1] = PRICER_LEG_S_EX.impliedVolatilityBachelier(resolvedLeg, MULTICURVE, rationalShift);
      }
    }
    StringBuilder builder = new StringBuilder();
    ExportUtils.exportArray(headers, iv, builder);
    System.out.println(builder.toString());  // Results printed on the console
  }

  /* Computes the smile of implied volatilities with one parameter changed. */
  public void smile_changes() throws IOException {
    int maturityIndex = 4;
    int parameterIndex = 7; // TODO: Parameter changed in this simulation; select of of the parameter set
//    double[] parametersChanged = {0.75, 0.50, 0.65, 0.85, 1.00}; // A1 - 0
//    double[] parametersChanged = {0.50, 0.30, 0.40, 0.60, 0.70}; // b00 - 3
//    double[] parametersChanged = {0.01, 0.005, 0.0075, 0.0125, 0.015}; // eta - 4
//    double[] parametersChanged = {0.03, 0.001, 0.005, 0.05, 0.10, 0.15}; // kappa - 5
    double[] parametersChanged = {0.00, -0.01, -0.001, 0.005, 0.01, 0.02}; // c2 - 7
    int nbParamShifts = parametersChanged.length;
    String[] headers = new String[nbParamShifts + 1];
    headers[0] = "0.0";
    for (int k = 0; k < nbParamShifts; k++) {
      headers[k + 1] = Double.toString(parametersChanged[k]);
    }
    LocalDate spot = EUR_EURIBOR_6M.calculateEffectiveFromFixing(VALUATION_DATE, REF_DATA);
    double[][] iv = new double[NB_MATURITIES][nbParamShifts + 1];
    LocalDate maturity = spot.plus(MATURITIES_PER[maturityIndex]);
    PeriodicSchedule paySchedule =
        PeriodicSchedule.of(spot, maturity, Frequency.P6M, BUSINESS_ADJ, StubConvention.NONE,
            RollConventions.NONE);
    for (int k = 0; k < NB_STRIKES; k++) {
      iv[k][0] = STRIKES[k];
      IborCapFloorLeg leg = IborCapFloorLeg.builder()
          .currency(EUR)
          .calculation(IborRateCalculation.of(EUR_EURIBOR_6M))
          .capSchedule(ValueSchedule.of(STRIKES[k]))
          .notional(ValueSchedule.of(NOTIONAL))
          .paymentSchedule(paySchedule)
          .payReceive(PayReceive.PAY).build();
      ResolvedIborCapFloorLeg resolvedLeg = leg.resolve(REF_DATA);
      for (int j = 0; j < nbParamShifts; j++) {
        RationalTwoFactorHWShapePlusCstParameters rationalShift =
            RATIONAL2.withParameter(parameterIndex, parametersChanged[j]);
        iv[k][j + 1] = PRICER_LEG_S_EX.impliedVolatilityBachelier(resolvedLeg, MULTICURVE, rationalShift);
      }
    }
    StringBuilder builder = new StringBuilder();
    ExportUtils.exportArray(headers, iv, builder);
    System.out.println(builder.toString());  // Results printed on the console
  }

}
